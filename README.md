# Homework 1. POSIX threads

Ваша задача - реализовать классический паттерн producer-consumer с небольшими дополнительными условиями. Программа должна состоять из 3+N потоков:
1. Главный
2. producer
3. interruptor
4. N потоков consumer

В файл, чтение которого уже реализовано в шаблоне кода в блокирующкем режиме, пишется список чисел, разделённых пробелом (читать можно до переноса строки). Длина списка чисел не задаётся - считывание происходит до перевода каретки.
- Задача producer-потока - получить на вход список чисел, и по очереди использовать каждое значение из этого списка для обновления переменной разделяемой между потоками
- Задача consumer-потоков отреагировать на уведомление от producer и набирать сумму полученных значений. Также этот поток должен защититься от попыток потока-interruptor его остановить. Дополнительные условия:
    1. Функция, исполняющая код этого потока consumer_routine, должна принимать указатель на объект/переменную, из которого будет читать обновления
    2. После суммирования переменной поток должен заснуть на случайное количество миллисекунд, верхний предел будет передан на вход приложения (0 миллисекунд также должно корректно обрабатываться). Вовремя сна поток не должен мешать другим потокам consumer выполнять свои задачи, если они есть
    3. Потоки consumer не должны дублировать вычисления друг с другом одних и тех же значений
    4. В качестве возвращаемого значения поток должен вернуть свою частичную посчитанную сумму
- Задача потока-interruptor проста: пока происходит процесс обновления значений, он должен постоянно пытаться остановить случайный поток consumer (вычисление случайного потока происходит перед каждой попыткой остановки). Как только поток producer произвел последнее обновление, этот поток завершается. В этом потоке можно выполнять вспомогательные действия которые помогут корректно обработать сигнал
- Завершение приложения происходит или при считывании перевода каретки из файла или по посылке сигнала SIGTERM, обработку которого нужно также добавить. В обработчике сигнала можно вызывать только signal-safe функции https://man7.org/linux/man-pages/man7/signal-safety.7.html В случае, если в этот момент поток, читающий данные с файла, находится в режиме блокирующего чтения, - он также должен корректно завершиться. Полезно присмотреться к std::sig_atomic_t - позволяет потокобезопасно и signal-safe обращаться к переменной такого типа.
- В нашем producer/consumer необходимо реализоваться потоковую обрботку данных для этих целей запрещается загружать весь файл в ОЗУ, иначе на больших файлах обработка не будет помещаться в ограничения ОЗУ на вычислительном устройстве.

Функция run_threads должна запускать все потоки, дожидаться их выполнения, и возвращать результат общего суммирования.

Для обеспечения межпоточного взаимодействия допускается использование только pthread API. На вход приложения передаётся 2 аргумента при старте именно в такой последовательности:
1. Число потоков consumer
2. Верхний предел сна consumer в миллисекундах

В поток вывода должно попадать только результирующее значение, по умолчанию никакой отладочной или запросной информации выводиться не должно. В случае детектирования ошибок нужно выдавать не нулевой код возврата.


# Homework 2. Lock-free контейнер

Необходимо реализовать в lock-free стиле интерфейс, опубликованный в шаблоне репозитория github-classroom.
Дополнительные условности:
1. Имя класса реализации - SetImpl
2. Класс должен иметь конструктор без параметров
3. Pull Request должен содержать в части тестирования проходящие тесты корректности на основе lincheck
4. В реализации не предполагается увидеть стандартные контейнеры из java.util.concurrent
5. Гарантировать исполнение на JDK 11

# Homework 3. Coroutines Pipeline

В этом задании мы пишем аналог bash pipeline, что-то вроде:
```
cat log.txt | grep "ERROR" | awk '{print $2}' | sort | uniq -c
```
В таком pipeline stdout одной программы передаётся как stdin в другую программу

Роль pipe будут выполнять каналы, которые передают данные из одной функции в другую. Само задание по сути состоит из двух частей
1. Написание класс PipelineExecutor c методом execute который обеспечивает конвейерную обработку job-функций (аналог cat, grep, awk, …)
2. Написание нескольких функций, которые считают нам какую-то условную хеш-сумму от входных данных

Расчет хеш-суммы реализован следующей цепочкой:
- singleHash считает значение crc32(data)+“~”+crc32(md5(data)) ( конкатенация двух строк через ~), где data - то что пришло на вход (по сути - числа из первой функции)
- multiHash считает значение crc32(th+data)) (конкатенация цифры, приведённой к строке и строки), где th=0..5 ( т.е. 6 хешей на каждое входящее значение ), потом берёт конкатенацию результатов в порядке расчета (0..5), где data - то что пришло на вход (и ушло на выход из singleHash)
- combineResults получает все результаты, сортирует, объединяет отсортированный результат через _ (символ подчеркивания) в одну строку
- crc32 считается через функцию dataSignerCrc32
- md5 считается через dataSignerMd5

В чем подвох:
- dataSignerMd5 может одновременно вызываться только 1 раз, считается 10 мс. Если одновременно запустится несколько - будет перегрев на 1 сек
- dataSignerCrc32, считается 1 сек
- На все расчеты у нас 3 сек.
- Если делать в лоб, линейно - для 7 элементов это займёт почти 57 секунд, следовательно надо это как-то распараллелить